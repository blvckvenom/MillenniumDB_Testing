#pragma once

#include "misc/logger.h"
#include "query/parser/grammar/error_listener.h"
#include "query/parser/grammar/mql/autogenerated/MQL_Lexer.h"
#include "query/parser/grammar/mql/autogenerated/MQL_Parser.h"
#include "query/parser/grammar/mql/query_visitor.h"
#include "query/parser/op/mql/op_project.h"
#include "query/parser/op/op.h"
#include <regex>
#include "query/rewriter/mql/op/check_var_names.h"
#include "query/rewriter/mql/op/check_well_designed.h"
#include "query/rewriter/mql/op/optimize_optional_tree.h"
#include "query/rewriter/mql/op/push_text_search.h"

namespace MQL {

class QueryParser {
public:
    static std::unique_ptr<Op> get_query_plan(const std::string& query)
    {
        auto trimmed = query;
        trimmed.erase(0, trimmed.find_first_not_of(" \t\n\r"));
        trimmed.erase(trimmed.find_last_not_of(" \t\n\r") + 1);
        if (!trimmed.empty() && trimmed.back() == ';') {
            trimmed.pop_back();
            trimmed.erase(trimmed.find_last_not_of(" \t\n\r") + 1);
        }

        if (trimmed.rfind("CALL project", 0) == 0) {
            auto open = trimmed.find('(');
            auto close = trimmed.rfind(')');
            if (open != std::string::npos && close != std::string::npos && close > open) {
                auto inside = trimmed.substr(open + 1, close - open - 1);
                std::vector<std::string> parts;
                bool in_str = false; std::string cur; char prev = 0;
                for (char c : inside) {
                    if (in_str) {
                        if (c == '"' && prev != '\\') {
                            parts.push_back(cur);
                            cur.clear();
                            in_str = false;
                        } else {
                            cur += c;
                        }
                    } else if (c == '"') {
                        in_str = true;
                    }
                    prev = c;
                }
                if (parts.size() == 3) {
                    auto op = std::make_unique<OpProject>(parts[0], parts[1], parts[2]);
                    logger(Category::LogicalPlan) << "Initial logical plan:\n" << *op;
                    return op;
                }
            }
        }

        std::string graph_name;
        std::regex in_graph_regex("IN\\s+graph\\(\"([^\"]+)\"\\)");
        std::smatch match;
        if (std::regex_search(trimmed, match, in_graph_regex)) {
            graph_name = match[1];
            trimmed = std::regex_replace(trimmed, in_graph_regex, "");
        }

        const std::string& query_no_graph = graph_name.empty() ? trimmed : trimmed;

        antlr4::ANTLRInputStream input(query_no_graph);
        MQL_Lexer lexer(&input);
        antlr4::CommonTokenStream tokens(&lexer);
        MQL_Parser parser(&tokens);

        parser.getInterpreter<antlr4::atn::ParserATNSimulator>()->setPredictionMode(
            antlr4::atn::PredictionMode::SLL
        );

        antlr4::MyErrorListener error_listener;
        parser.removeErrorListeners();
        parser.addErrorListener(&error_listener);

        MQL_Parser::RootContext* tree = parser.root();
        QueryVisitor visitor;
        visitor.visitRoot(tree);

        auto res = std::move(visitor.current_op);

        if (!graph_name.empty()) {
            struct SetInGraph : public OpVisitor {
                std::string name;
                bool done = false;
                explicit SetInGraph(std::string n) : name(std::move(n)) {}
                void visit(OpBasicGraphPattern& op) override {
                    if (!done) { op.in_graph = name; done = true; }
                }
                void visit(OpWhere& op) override { op.op->accept_visitor(*this); }
                void visit(OpGroupBy& op) override { op.op->accept_visitor(*this); }
                void visit(OpOrderBy& op) override { op.op->accept_visitor(*this); }
                void visit(OpReturn& op) override { op.op->accept_visitor(*this); }
                void visit(OpOptional& op) override {
                    op.op->accept_visitor(*this);
                    for (auto& ch: op.optionals) ch->accept_visitor(*this);
                }
                void visit(OpSet& op) override { op.op->accept_visitor(*this); }
                void visit(OpProject&) override {}
                void visit(OpShow&) override {}
                void visit(OpDescribe&) override {}
                void visit(OpInsert&) override {}
                void visit(OpInsertTensors&) override {}
                void visit(OpCreateTensorStore&) override {}
                void visit(OpCreateTextSearchIndex&) override {}
                void visit(OpDeleteTensors&) override {}
                void visit(OpDisjointTerm&) override {}
                void visit(OpDisjointVar&) override {}
                void visit(OpLabel&) override {}
                void visit(OpPath&) override {}
                void visit(OpProperty&) override {}
            } setter(graph_name);
            res->accept_visitor(setter);
        }

        logger(Category::LogicalPlan) << "Initial logical plan:\n" << *res;

        CheckVarNames check_var_names(std::move(visitor.optional_properties));
        res->accept_visitor(check_var_names);

        CheckWellDesigned check_well_designed;
        res->accept_visitor(check_well_designed);

        OptimizeOptionalTree optimize_optional_tree;
        res->accept_visitor(optimize_optional_tree);

        PushTextSearch push_text_search;
        res->accept_visitor(push_text_search);

        // TODO: push negation inside, simplify constant expressions

        //PushWhere push_where;
        //res->accept_visitor(push_where);

        logger(Category::LogicalPlan) << *res;

        return res;
    }
};
} // namespace MQL
