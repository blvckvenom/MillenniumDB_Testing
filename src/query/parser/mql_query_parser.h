#pragma once

#include "misc/logger.h"
#include "query/parser/grammar/error_listener.h"
#include "query/parser/grammar/mql/autogenerated/MQL_Lexer.h"
#include "query/parser/grammar/mql/autogenerated/MQL_Parser.h"
#include "query/parser/grammar/mql/query_visitor.h"
#include "query/parser/op/mql/op_project.h"
#include "query/parser/op/op.h"
#include "query/exceptions.h"
#include <regex>
#include "query/rewriter/mql/op/check_var_names.h"
#include "query/rewriter/mql/op/check_well_designed.h"
#include "query/rewriter/mql/op/optimize_optional_tree.h"
#include "query/rewriter/mql/op/push_text_search.h"

namespace MQL {

class QueryParser {
public:
    static std::unique_ptr<Op> parse_call(const std::string& query)
    {
        // Trim trailing semicolon and spaces
        auto trimmed = query;
        trimmed.erase(0, trimmed.find_first_not_of(" \t\n\r"));
        trimmed.erase(trimmed.find_last_not_of(" \t\n\r") + 1);
        if (!trimmed.empty() && trimmed.back() == ';') {
            trimmed.pop_back();
            trimmed.erase(trimmed.find_last_not_of(" \t\n\r") + 1);
        }

        static const std::regex proj_re(
            R"(^CALL\s+project\s*\(\s*\"((?:[^\"\\]|\\.)*)\"\s*,\s*\"((?:[^\"\\]|\\.)*)\"\s*,\s*\"((?:[^\"\\]|\\.)*)\"\s*\)$)",
            std::regex::optimize);

        std::smatch match;
        if (!std::regex_match(trimmed, match, proj_re))
            throw QueryParsingException("Malformed CALL project syntax", 0, 0);

        auto unescape = [](const std::string& s) {
            std::string out; out.reserve(s.size());
            bool esc = false;
            for (char c : s) {
                if (esc) { out.push_back(c); esc = false; }
                else if (c == '\\') esc = true;
                else out.push_back(c);
            }
            return out;
        };

        return std::make_unique<OpProject>(
            unescape(match[1].str()),
            unescape(match[2].str()),
            unescape(match[3].str()));
    }

    static std::unique_ptr<Op> get_query_plan(const std::string& query)
    {
        auto trimmed = query;
        trimmed.erase(0, trimmed.find_first_not_of(" \t\n\r"));
        trimmed.erase(trimmed.find_last_not_of(" \t\n\r") + 1);
        if (!trimmed.empty() && trimmed.back() == ';') {
            trimmed.pop_back();
            trimmed.erase(trimmed.find_last_not_of(" \t\n\r") + 1);
        }

        if (trimmed.rfind("CALL", 0) == 0) {
            auto op = parse_call(trimmed);
            logger(Category::LogicalPlan) << "Initial logical plan:\n" << *op;
            return op;
        }

        std::string graph_name;
        std::regex in_graph_regex("IN\\s+graph\\(\"([^\"]+)\"\\)");
        std::smatch match;
        if (std::regex_search(trimmed, match, in_graph_regex)) {
            graph_name = match[1];
            trimmed = std::regex_replace(trimmed, in_graph_regex, "");
        }

        const std::string& query_no_graph = graph_name.empty() ? trimmed : trimmed;

        antlr4::ANTLRInputStream input(query_no_graph);
        MQL_Lexer lexer(&input);
        antlr4::CommonTokenStream tokens(&lexer);
        MQL_Parser parser(&tokens);

        parser.getInterpreter<antlr4::atn::ParserATNSimulator>()->setPredictionMode(
            antlr4::atn::PredictionMode::SLL
        );

        antlr4::MyErrorListener error_listener;
        parser.removeErrorListeners();
        parser.addErrorListener(&error_listener);

        MQL_Parser::RootContext* tree = parser.root();
        QueryVisitor visitor;
        visitor.visitRoot(tree);

        auto res = std::move(visitor.current_op);

        if (!graph_name.empty()) {
            struct SetInGraph : public OpVisitor {
                std::string name;
                bool done = false;
                explicit SetInGraph(std::string n) : name(std::move(n)) {}
                void visit(OpBasicGraphPattern& op) override {
                    if (!done) { op.in_graph = name; done = true; }
                }
                void visit(OpWhere& op) override { op.op->accept_visitor(*this); }
                void visit(OpGroupBy& op) override { op.op->accept_visitor(*this); }
                void visit(OpOrderBy& op) override { op.op->accept_visitor(*this); }
                void visit(OpReturn& op) override { op.op->accept_visitor(*this); }
                void visit(OpOptional& op) override {
                    op.op->accept_visitor(*this);
                    for (auto& ch: op.optionals) ch->accept_visitor(*this);
                }
                void visit(OpSet& op) override { op.op->accept_visitor(*this); }
                void visit(OpProject&) override {}
                void visit(OpShow&) override {}
                void visit(OpDescribe&) override {}
                void visit(OpInsert&) override {}
                void visit(OpInsertTensors&) override {}
                void visit(OpCreateTensorStore&) override {}
                void visit(OpCreateTextSearchIndex&) override {}
                void visit(OpDeleteTensors&) override {}
                void visit(OpDisjointTerm&) override {}
                void visit(OpDisjointVar&) override {}
                void visit(OpLabel&) override {}
                void visit(OpPath&) override {}
                void visit(OpProperty&) override {}
            } setter(graph_name);
            res->accept_visitor(setter);
        }

        logger(Category::LogicalPlan) << "Initial logical plan:\n" << *res;

        CheckVarNames check_var_names(std::move(visitor.optional_properties));
        res->accept_visitor(check_var_names);

        CheckWellDesigned check_well_designed;
        res->accept_visitor(check_well_designed);

        OptimizeOptionalTree optimize_optional_tree;
        res->accept_visitor(optimize_optional_tree);

        PushTextSearch push_text_search;
        res->accept_visitor(push_text_search);

        // TODO: push negation inside, simplify constant expressions

        //PushWhere push_where;
        //res->accept_visitor(push_where);

        logger(Category::LogicalPlan) << *res;

        return res;
    }
};
} // namespace MQL
